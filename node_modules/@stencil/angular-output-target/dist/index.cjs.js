'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = _interopDefault(require('path'));
var util = require('util');
var fs = _interopDefault(require('fs'));

const readFile = util.promisify(fs.readFile);
const toLowerCase = (str) => str.toLowerCase();
const dashToPascalCase = (str) => toLowerCase(str)
    .split('-')
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join('');
function sortBy(array, prop) {
    return array.slice().sort((a, b) => {
        const nameA = prop(a);
        const nameB = prop(b);
        if (nameA < nameB)
            return -1;
        if (nameA > nameB)
            return 1;
        return 0;
    });
}
function normalizePath(str) {
    // Convert Windows backslash paths to slash paths: foo\\bar âž” foo/bar
    // https://github.com/sindresorhus/slash MIT
    // By Sindre Sorhus
    if (typeof str !== 'string') {
        throw new Error(`invalid path to normalize`);
    }
    str = str.trim();
    if (EXTENDED_PATH_REGEX.test(str) || NON_ASCII_REGEX.test(str)) {
        return str;
    }
    str = str.replace(SLASH_REGEX, '/');
    // always remove the trailing /
    // this makes our file cache look ups consistent
    if (str.charAt(str.length - 1) === '/') {
        const colonIndex = str.indexOf(':');
        if (colonIndex > -1) {
            if (colonIndex < str.length - 2) {
                str = str.substring(0, str.length - 1);
            }
        }
        else if (str.length > 1) {
            str = str.substring(0, str.length - 1);
        }
    }
    return str;
}
function relativeImport(pathFrom, pathTo, ext) {
    let relativePath = path.relative(path.dirname(pathFrom), path.dirname(pathTo));
    if (relativePath === '') {
        relativePath = '.';
    }
    else if (relativePath[0] !== '.') {
        relativePath = './' + relativePath;
    }
    return normalizePath(`${relativePath}/${path.basename(pathTo, ext)}`);
}
async function readPackageJson(rootDir) {
    const pkgJsonPath = path.join(rootDir, 'package.json');
    let pkgJson;
    try {
        pkgJson = await readFile(pkgJsonPath, 'utf8');
    }
    catch (e) {
        throw new Error(`Missing "package.json" file for distribution: ${pkgJsonPath}`);
    }
    let pkgData;
    try {
        pkgData = JSON.parse(pkgJson);
    }
    catch (e) {
        throw new Error(`Error parsing package.json: ${pkgJsonPath}, ${e}`);
    }
    return pkgData;
}
const EXTENDED_PATH_REGEX = /^\\\\\?\\/;
const NON_ASCII_REGEX = /[^\x00-\x80]+/;
const SLASH_REGEX = /\\/g;

const createComponentDefinition = (componentCorePackage, distTypesDir, rootDir) => (cmpMeta) => {
    // Collect component meta
    const inputs = [
        ...cmpMeta.properties.filter((prop) => !prop.internal).map((prop) => prop.name),
        ...cmpMeta.virtualProperties.map((prop) => prop.name),
    ].sort();
    const outputs = cmpMeta.events.filter((ev) => !ev.internal).map((prop) => prop);
    const methods = cmpMeta.methods.filter((method) => !method.internal).map((prop) => prop.name);
    // Process meta
    const hasOutputs = outputs.length > 0;
    // Generate Angular @Directive
    const directiveOpts = [
        `selector: \'${cmpMeta.tagName}\'`,
        `changeDetection: ChangeDetectionStrategy.OnPush`,
        `template: '<ng-content></ng-content>'`,
    ];
    if (inputs.length > 0) {
        directiveOpts.push(`inputs: ['${inputs.join(`', '`)}']`);
    }
    if (outputs.length > 0) {
        directiveOpts.push(`outputs: ['${outputs.map((output) => output.name).join(`', '`)}']`);
    }
    const tagNameAsPascal = dashToPascalCase(cmpMeta.tagName);
    const typePath = path.parse(path.join(componentCorePackage, path.join(cmpMeta.sourceFilePath, '').replace(path.join(rootDir, 'src'), distTypesDir)));
    const importPath = normalizePath(path.join(typePath.dir, typePath.name));
    const outputsInterface = outputs.length > 0
        ? `import { ${cmpMeta.componentClassName} as I${cmpMeta.componentClassName} } from '${importPath}';`
        : '';
    const lines = [
        `
${outputsInterface}
export declare interface ${tagNameAsPascal} extends Components.${tagNameAsPascal} {}
${getProxyCmp(inputs, methods)}
@Component({
  ${directiveOpts.join(',\n  ')}
})
export class ${tagNameAsPascal} {`,
    ];
    // Generate outputs
    outputs.forEach((output) => {
        lines.push(`  /** ${output.docs.text} ${output.docs.tags.map((tag) => `@${tag.name} ${tag.text}`)}*/`);
        lines.push(`  ${output.name}!: I${cmpMeta.componentClassName}['${output.method}'];`);
    });
    lines.push('  protected el: HTMLElement;');
    lines.push(`  constructor(c: ChangeDetectorRef, r: ElementRef, protected z: NgZone) {
    c.detach();
    this.el = r.nativeElement;`);
    if (hasOutputs) {
        lines.push(`    proxyOutputs(this, this.el, ['${outputs.map((output) => output.name).join(`', '`)}']);`);
    }
    lines.push(`  }`);
    lines.push(`}`);
    return lines.join('\n');
};
function getProxyCmp(inputs, methods) {
    const hasInputs = inputs.length > 0;
    const hasMethods = methods.length > 0;
    const proxMeta = [];
    if (!hasInputs && !hasMethods) {
        return '';
    }
    if (hasInputs)
        proxMeta.push(`inputs: ['${inputs.join(`', '`)}']`);
    if (hasMethods)
        proxMeta.push(`methods: ['${methods.join(`', '`)}']`);
    return `@ProxyCmp({\n  ${proxMeta.join(',\n  ')}\n})`;
}

function generateAngularDirectivesFile(compilerCtx, components, outputTarget) {
    // Only create the file if it is defined in the stencil configuration
    if (!outputTarget.directivesArrayFile) {
        return Promise.resolve();
    }
    const proxyPath = relativeImport(outputTarget.directivesArrayFile, outputTarget.directivesProxyFile, '.ts');
    const directives = components
        .map((cmpMeta) => dashToPascalCase(cmpMeta.tagName))
        .map((className) => `d.${className}`)
        .join(',\n  ');
    const c = `
import * as d from '${proxyPath}';

export const DIRECTIVES = [
${directives}
];
`;
    return compilerCtx.fs.writeFile(outputTarget.directivesArrayFile, c);
}

async function generateValueAccessors(compilerCtx, components, outputTarget, config) {
    if (!Array.isArray(outputTarget.valueAccessorConfigs) ||
        outputTarget.valueAccessorConfigs.length === 0) {
        return;
    }
    const targetDir = path.dirname(outputTarget.directivesProxyFile);
    const normalizedValueAccessors = outputTarget.valueAccessorConfigs.reduce((allAccessors, va) => {
        const elementSelectors = Array.isArray(va.elementSelectors)
            ? va.elementSelectors
            : [va.elementSelectors];
        const type = va.type;
        let allElementSelectors = [];
        let allEventTargets = [];
        if (allAccessors.hasOwnProperty(type)) {
            allElementSelectors = allAccessors[type].elementSelectors;
            allEventTargets = allAccessors[type].eventTargets;
        }
        return Object.assign(Object.assign({}, allAccessors), { [type]: {
                elementSelectors: allElementSelectors.concat(elementSelectors),
                eventTargets: allEventTargets.concat([[va.event, va.targetAttr]]),
            } });
    }, {});
    await Promise.all(Object.keys(normalizedValueAccessors).map(async (type) => {
        const valueAccessorType = type; // Object.keys converts to string
        const targetFileName = `${type}-value-accessor.ts`;
        const targetFilePath = path.join(targetDir, targetFileName);
        const srcFilePath = path.join(__dirname, '../resources/control-value-accessors/', targetFileName);
        const srcFileContents = await compilerCtx.fs.readFile(srcFilePath);
        const finalText = createValueAccessor(srcFileContents, normalizedValueAccessors[valueAccessorType]);
        await compilerCtx.fs.writeFile(targetFilePath, finalText);
    }));
    await copyResources(config, ['value-accessor.ts'], targetDir);
}
function createValueAccessor(srcFileContents, valueAccessor) {
    const hostContents = valueAccessor.eventTargets.map((listItem) => VALUE_ACCESSOR_EVENTTARGETS.replace(VALUE_ACCESSOR_EVENT, listItem[0]).replace(VALUE_ACCESSOR_TARGETATTR, listItem[1]));
    return srcFileContents
        .replace(VALUE_ACCESSOR_SELECTORS, valueAccessor.elementSelectors.join(', '))
        .replace(VALUE_ACCESSOR_EVENTTARGETS, hostContents.join('\n'));
}
function copyResources(config, resourcesFilesToCopy, directory) {
    if (!config.sys || !config.sys.copy) {
        throw new Error('stencil is not properly intialized at this step. Notify the developer');
    }
    const copyTasks = resourcesFilesToCopy.map((rf) => {
        return {
            src: path.join(__dirname, '../resources/control-value-accessors/', rf),
            dest: path.join(directory, rf),
            keepDirStructure: false,
            warn: false,
        };
    });
    return config.sys.copy(copyTasks, path.join(directory));
}
const VALUE_ACCESSOR_SELECTORS = `<VALUE_ACCESSOR_SELECTORS>`;
const VALUE_ACCESSOR_EVENT = `<VALUE_ACCESSOR_EVENT>`;
const VALUE_ACCESSOR_TARGETATTR = '<VALUE_ACCESSOR_TARGETATTR>';
const VALUE_ACCESSOR_EVENTTARGETS = `    '(<VALUE_ACCESSOR_EVENT>)': 'handleChangeEvent($event.target.<VALUE_ACCESSOR_TARGETATTR>)'`;

async function angularDirectiveProxyOutput(compilerCtx, outputTarget, components, config) {
    const filteredComponents = getFilteredComponents(outputTarget.excludeComponents, components);
    const rootDir = config.rootDir;
    const pkgData = await readPackageJson(rootDir);
    const finalText = generateProxies(filteredComponents, pkgData, outputTarget, config.rootDir);
    await Promise.all([
        compilerCtx.fs.writeFile(outputTarget.directivesProxyFile, finalText),
        copyResources$1(config, outputTarget),
        generateAngularDirectivesFile(compilerCtx, filteredComponents, outputTarget),
        generateValueAccessors(compilerCtx, filteredComponents, outputTarget, config),
    ]);
}
function getFilteredComponents(excludeComponents = [], cmps) {
    return sortBy(cmps, (cmp) => cmp.tagName).filter((c) => !excludeComponents.includes(c.tagName) && !c.internal);
}
async function copyResources$1(config, outputTarget) {
    if (!config.sys || !config.sys.copy || !config.sys.glob) {
        throw new Error('stencil is not properly initialized at this step. Notify the developer');
    }
    const srcDirectory = path.join(__dirname, '..', 'angular-component-lib');
    const destDirectory = path.join(path.dirname(outputTarget.directivesProxyFile), 'angular-component-lib');
    return config.sys.copy([
        {
            src: srcDirectory,
            dest: destDirectory,
            keepDirStructure: false,
            warn: false,
        },
    ], srcDirectory);
}
function generateProxies(components, pkgData, outputTarget, rootDir) {
    const distTypesDir = path.dirname(pkgData.types);
    const dtsFilePath = path.join(rootDir, distTypesDir, GENERATED_DTS);
    const componentsTypeFile = relativeImport(outputTarget.directivesProxyFile, dtsFilePath, '.d.ts');
    const imports = `/* tslint:disable */
/* auto-generated angular directive proxies */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, NgZone } from '@angular/core';
import { ProxyCmp, proxyOutputs } from './angular-component-lib/utils';\n`;
    const typeImports = !outputTarget.componentCorePackage
        ? `import { ${IMPORT_TYPES} } from '${normalizePath(componentsTypeFile)}';`
        : `import { ${IMPORT_TYPES} } from '${normalizePath(outputTarget.componentCorePackage)}';`;
    const final = [
        imports,
        typeImports,
        components
            .map(createComponentDefinition(outputTarget.componentCorePackage, distTypesDir, rootDir))
            .join('\n'),
    ];
    return final.join('\n') + '\n';
}
const GENERATED_DTS = 'components.d.ts';
const IMPORT_TYPES = 'Components';

const angularOutputTarget = (outputTarget) => ({
    type: 'custom',
    name: 'angular-library',
    validate(config) {
        return normalizeOutputTarget(config, outputTarget);
    },
    async generator(config, compilerCtx, buildCtx) {
        const timespan = buildCtx.createTimeSpan(`generate angular proxies started`, true);
        await angularDirectiveProxyOutput(compilerCtx, outputTarget, buildCtx.components, config);
        timespan.finish(`generate angular proxies finished`);
    },
});
function normalizeOutputTarget(config, outputTarget) {
    const results = Object.assign(Object.assign({}, outputTarget), { excludeComponents: outputTarget.excludeComponents || [], valueAccessorConfig: outputTarget.valueAccessorConfig || [] });
    if (config.rootDir == null) {
        throw new Error('rootDir is not set and it should be set by stencil itself');
    }
    if (outputTarget.directivesProxyFile == null) {
        throw new Error('directivesProxyFile is required');
    }
    if (outputTarget.directivesProxyFile && !path.isAbsolute(outputTarget.directivesProxyFile)) {
        results.directivesProxyFile = normalizePath(path.join(config.rootDir, outputTarget.directivesProxyFile));
    }
    if (outputTarget.directivesArrayFile && !path.isAbsolute(outputTarget.directivesArrayFile)) {
        results.directivesArrayFile = normalizePath(path.join(config.rootDir, outputTarget.directivesArrayFile));
    }
    if (outputTarget.directivesUtilsFile && !path.isAbsolute(outputTarget.directivesUtilsFile)) {
        results.directivesUtilsFile = normalizePath(path.join(config.rootDir, outputTarget.directivesUtilsFile));
    }
    return results;
}

exports.angularOutputTarget = angularOutputTarget;
